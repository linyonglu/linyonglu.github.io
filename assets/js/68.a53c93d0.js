(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{553:function(a,t,e){"use strict";e.r(t);var i=e(20),c=Object(i.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[a._v("#")]),a._v(" 简介")]),a._v(" "),t("p",[a._v("CDN （Content Delivery Network，即内容分发网络）指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。")]),a._v(" "),t("p",[a._v("“缓存”就是说我们把资源 copy 一份到 CDN 服务器上这个过程；“回源”就是说 CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程。CDN回源回源原理源站内容有更新的时候，源站主动把内容推送到CDN节点。常规的CDN都是回源的。即：当有用户访问某一个URL的时候，如果被解析到的那个CDN节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。如果没有人访问，那么CDN节点不会主动去源站拿的。")]),a._v(" "),t("p",[a._v("回源域名一般是cdn领域的专业术语，通常情况下，是直接用ip进行回源的，但是如果客户源站有多个ip，并且ip地址会经常变化，对于cdn厂商来说，为了避免经常更改配置（回源ip），会采用回源域名方式进行回源，这样即使源站的ip变化了，也不影响原有的配置。")]),a._v(" "),t("img",{staticClass:"origin_image zh-lightbox-thumb",attrs:{src:"https://picx.zhimg.com/50/v2-d5bac8533f77110c2e4ef7f6cea76e28_720w.jpg?source=2c26e567","data-rawwidth":"1331","data-rawheight":"750","data-size":"normal","data-caption":"","data-original-token":"v2-d5bac8533f77110c2e4ef7f6cea76e28",width:"1331","data-original":"https://picx.zhimg.com/v2-d5bac8533f77110c2e4ef7f6cea76e28_r.jpg?source=2c26e567"}}),a._v(" "),t("p",[a._v("回源比分为回源请求数比例及回源流量比例回源请求数比：统计数据来自所有边缘节点上的请求记录，其中，对于没有缓存或缓存过期（可缓存）的请求以及不可缓存的请求，均计入回源请求中，其他直接命中缓存的，则为命中请求。回源流量比：回源流量是回源请求文件大小产生的流量和请求本身产生的流量 回源流量比=回源流量/回源流量+用户请求访问的流量CDN本来是给我们的网站加速的，但是有时会因为不合适的回源策略给服务器带来负担，只有选择正确的策略才能给自己的网站带来更高的访问效率。")]),a._v(" "),t("p",[a._v("CDN缓存首先，看看没有网站没有接入CDN时，用户浏览器与服务器是如何交互的：用户在浏览网站的时候，浏览器能够在本地保存网站中的图片或者其他文件的副本，这样用户再次访问该网站的时候，浏览器就不用再下载全部的文件，减少了下载量意味着提高了页面加载的速度。客户端浏览器先检查是否有本地缓存是否过期，如果过期，则向CDN边缘节点发起请求，CDN边缘节点会检测用户请求数据的缓存是否过期，如果没有过期，则直接响应用户请求，此时一个完成http请求结束；如果数据已经过期，那么CDN还需要向源站发出回源请求（back to the source request）,来拉取最新的数据。可以看到，在存在CDN的场景下，数据经历了客户端（浏览器）缓存和CDN边缘节点缓存两个阶段，下面分别对这两个阶段的缓存进行详细的剖析客户端（浏览器）缓存客户端缓存的缺点 客户端缓存减少了的服务器请求，避免了文件重复加载，显著地提升了用户地方。但是当网站发生了更新的时候（如替换了css、js以及图片文件），浏览器本地仍保存着旧版本的文件，从而导致无法预料后果。")]),a._v(" "),t("p",[a._v("曾几何时，一个页面加载出来，页面各元素位置乱飘，按钮点击失效，前端GG都会习惯性地问一句：“缓存清了没？”，然后Ctrl+F5       ，Everything is OK。但有些时候，如果我们是简单地在浏览器地址栏中敲一个回车，或者是仅仅按F5刷新，问题依然没有解决，你可知道这三种不同的操作方式，决定浏览器不同的刷新缓存策略？浏览器如何来确定使用本地文件还是使用服务器上的新文件？")]),a._v(" "),t("p",[a._v("下面来介绍几种判断的方法。浏览器缓存策略如果http响应报文中设置了Expires，在Expires过期之前，我们就避免了和服务器之间的连接。此时，浏览器无需想浏览器发出请求，只需要自己判断手中的材料是否过期就可以了，完全不需要增加服务器的负担。服务器为了通知浏览器当前文件的版本，会发送一个上次修改时间的标签，例如：Last-Modified:Tue, 06 Jan 2015 08:26:32 GMT这样浏览器就知道他收到的这个文件创建时间，在后续的请求中，浏览器会按照下面的规则进行验证：浏览器：Hey，我需要jquery.min.js这个文件，如果是在 Tue, 06 Jan 2015 08:26:32 GMT 之后修改过的，请发给我。服务器：（检查文件的修改时间）服务器：Hey，这个文件在那个时间之后没有被修改过，你已经有最新的版本了。浏览器：太好了，那我就显示给用户了。在这种情况下，服务器仅仅返回了一个304的响应头，减少了响应的数据量，提高了响应的速度。ETag 通常情况下，通过修改时间来比较文件是可行的。但是在一些特殊情况，例如服务器的时钟发生了错误，服务器时钟进行修改，夏时制DST到来后服务器时间没有及时更新，这些都会引起通过修改时间比较文件版本的问题。ETag可以用来解决这种问题。ETag是一个文件的唯一标志符。就像一个哈希或者指纹，每个文件都有一个单独的标志，只要这个文件发生了改变，这个标志就会发生变化。")]),a._v(" "),t("img",{staticClass:"origin_image zh-lightbox-thumb",attrs:{src:"https://picx.zhimg.com/50/v2-3b9b6ffc6ffae0e864a065566df1a151_720w.jpg?source=2c26e567","data-rawwidth":"1092","data-rawheight":"740","data-size":"normal","data-caption":"","data-original-token":"v2-3b9b6ffc6ffae0e864a065566df1a151",width:"1092","data-original":"https://pic1.zhimg.com/v2-3b9b6ffc6ffae0e864a065566df1a151_r.jpg?source=2c26e567"}}),a._v(" "),t("p",[a._v('服务器返回ETag标签：ETag:"39001d-1762a-50bf790757e00"接下来的访问顺序如下所示：浏览器：Hey，我需要jquery.min.js这个文件，有没有不匹配"39001d-1762a-50bf790757e00"这个串的服务器：（检查ETag…）服务器：Hey，我这里的版本也是"39001d-1762a-50bf790757e00"，你已经是最新的版本了浏览器：好，那就可以使用本地缓存了如同 Last-modified 一样，ETag 解决了文件版本比较的问题。只不过 ETag 的级别比 Last-Modified 高一些。额外的标签缓存标签永远不会停止工作，但是有时候我们需要对已经缓存的内容进行一些控制。')]),a._v(" "),t("p",[a._v("l  Cache-control: public 表示缓存的版本可以被代理服务器或者其他中间服务器识别。l  Cache-control: private 意味着这个文件对不同的用户是不同的。只有用户自己的浏览器能够进行缓存，公共的代理服务器不允许缓存。l  Cache-control: no-cache 意味着文件的内容不应当被缓存。这在搜索或者翻页结果中非常有用，因为同样的URL，对应的内容会发生变化。 浏览器缓存刷新 在地址栏中输入网址后按回车或点击转到按钮浏览器以最少的请求来获取网页的数据，浏览器会对所有没有过期的内容直接使用本地缓存，从而减少了对浏览器的请求。所以，Expires，max-age标记只对这种方式有效。按F5或浏览器刷新按钮浏览器会在请求中附加必要的缓存协商，但不允许浏览器直接使用本地缓存，它能够让 Last-Modified、ETag发挥效果，但是对Expires无效。按Ctrl+F5或按Ctrl并点击刷新按钮这种方式就是强制刷新，总会发起一个全新的请求，不使用任何缓存。浏览器本地缓存失效后，浏览器会向CDN边缘节点发起请求。类似浏览器缓存，CDN边缘节点也存在着一套缓存机制。CDN边缘节点缓存的缺点 CDN的分流作用不仅减少了用户的访问延时，也减少的源站的负载。但其缺点也很明显：当网站更新时，如果CDN节点上数据没有及时更新，即便用户再浏览器使用Ctrl +F5的方式使浏览器端的缓存失效，也会因为CDN边缘节点没有同步最新数据而导致用户访问异常。CDN缓存策略 CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过http响应头中的Cache-control: max-age的字段来设置CDN边缘节点数据缓存时间。当客户端向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN节点就会向源站发出回源请求，从源站拉取最新数据，更新本地缓存，并将最新数据返回给客户端。")]),a._v(" "),t("p",[a._v("CDN服务商一般会提供基于文件后缀、目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。CDN缓存时间会对“回源率”产生直接的影响。若CDN缓存时间较短，CDN边缘节点上的数据会经常失效，导致频繁回源，增加了源站的负载，同时也增大的访问延时；若CDN缓存时间太长，会带来数据更新时间慢的问题。开发者需要增对特定的业务，来做特定的数据缓存时间管理。CDN缓存刷新CDN边缘节点对开发者是透明的，相比于浏览器Ctrl+F5的强制刷新来使浏览器本地缓存失效，开发者可以通过CDN服务商提供的“刷新缓存”接口来达到清理CDN边缘节点缓存的目的。这样开发者在更新数据后，可以使用“刷新缓存”功能来强制CDN节点上的数据缓存过期，保证客户端在访问时，拉取到最新的数据。CDN的基础架构")]),a._v(" "),t("img",{staticClass:"origin_image zh-lightbox-thumb",attrs:{src:"https://pic1.zhimg.com/50/v2-df54e3501feadc713158b844ea50c00f_720w.jpg?source=2c26e567","data-rawwidth":"1303","data-rawheight":"603","data-size":"normal","data-caption":"","data-original-token":"v2-df54e3501feadc713158b844ea50c00f",width:"1303","data-original":"https://pic1.zhimg.com/v2-df54e3501feadc713158b844ea50c00f_r.jpg?source=2c26e567"}})])}),[],!1,null,null,null);t.default=c.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{520:function(t,a,e){t.exports=e.p+"assets/img/1705027461745.dcf11746.jpg"},521:function(t,a,e){t.exports=e.p+"assets/img/1705027944948.5a149bb8.jpg"},522:function(t,a,e){t.exports=e.p+"assets/img/1705028609905.d04a318a.jpg"},551:function(t,a,e){"use strict";e.r(a);var s=e(20),r=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"简述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简述"}},[t._v("#")]),t._v(" 简述")]),t._v(" "),a("p",[t._v("react中的类组件是通过setState来实现数据改变时视图相应地做出改变，现在通过按钮点击事件触发setState，看看整个流程是怎么变化的")]),t._v(" "),a("h2",{attrs:{id:"流程分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#流程分析"}},[t._v("#")]),t._v(" 流程分析")]),t._v(" "),a("h3",{attrs:{id:"触发react的onclick事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#触发react的onclick事件"}},[t._v("#")]),t._v(" 触发react的onClick事件")]),t._v(" "),a("p",[a("img",{attrs:{src:e(520),alt:"onClick"}}),t._v("\n撇除react的事件合成机制和批量更新，从点击事件开始看setState的整个流程")]),t._v(" "),a("h3",{attrs:{id:"类组件中的setstate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类组件中的setstate"}},[t._v("#")]),t._v(" 类组件中的setState")]),t._v(" "),a("p",[a("img",{attrs:{src:e(521),alt:"setState"}}),t._v("\n可以看到setState是挂载在类组件中的prototype上的，我们通过调用this.setState,实际上就是调用原型上的setState方法")]),t._v(" "),a("h4",{attrs:{id:"参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参数"}},[t._v("#")]),t._v(" 参数")]),t._v(" "),a("ol",[a("li",[t._v("partialState：合成后的state，可以是对象，也可以是函数，函数需要返回一个合成后的对象。")]),t._v(" "),a("li",[t._v("callback：state改变后立即调用的回调函数")])]),t._v(" "),a("h4",{attrs:{id:"运作逻辑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#运作逻辑"}},[t._v("#")]),t._v(" 运作逻辑")]),t._v(" "),a("p",[t._v("调用updater对象的enqueueSetState，打开更新的主体流程")]),t._v(" "),a("h3",{attrs:{id:"enqueuesetstate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#enqueuesetstate"}},[t._v("#")]),t._v(" enqueueSetState")]),t._v(" "),a("p",[a("img",{attrs:{src:e(522),alt:"enqueueSetState"}}),t._v("\nenqueueSetState是classComponentUpdater对象的属性")]),t._v(" "),a("h4",{attrs:{id:"参数-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参数-2"}},[t._v("#")]),t._v(" 参数")]),t._v(" "),a("ol",[a("li",[t._v("inst：当前组件实例")]),t._v(" "),a("li",[t._v("payload：合成后的state对象")]),t._v(" "),a("li",[t._v("callback：state改变后立即调用的回调函数")])]),t._v(" "),a("h4",{attrs:{id:"运作逻辑-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#运作逻辑-2"}},[t._v("#")]),t._v(" 运作逻辑")]),t._v(" "),a("ol",[a("li",[t._v("通过组件实例获取组件的fiber对象")]),t._v(" "),a("li",[t._v("获取本次更新的lane，此属性主要为本次更新调度的优先级")]),t._v(" "),a("li",[t._v("创建update对象，将payload(合成后的state对象)和callback(state改变后立即调用的回调函数)赋值成update对象的属性")]),t._v(" "),a("li",[t._v("通过enqueueUpdate方法将当前更新对象推入react的更新队列中(fiber.updateQueue)")]),t._v(" "),a("li",[t._v("通过scheduleUpdateOnFiber根据优先级开始更新调度(等调度时再好好研究这个方法)")])])])}),[],!1,null,null,null);a.default=r.exports}}]);